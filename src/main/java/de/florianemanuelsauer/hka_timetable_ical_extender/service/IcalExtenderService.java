/*
 * Copyright (c) 2024 - present Florian Sauer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 * files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.florianemanuelsauer.hka_timetable_ical_extender.service;

import biweekly.Biweekly;
import biweekly.ICalendar;
import biweekly.property.Status;
import de.florianemanuelsauer.hka_timetable_ical_extender.repository.RaumzeitRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.UUID;

import static de.florianemanuelsauer.hka_timetable_ical_extender.controller.Controller.ACADEMIC_COURSE_PATTERN;
import static de.florianemanuelsauer.hka_timetable_ical_extender.controller.Controller.TERM_PATTERN;

/**
 * Service class for interpreting the request parameters and loading & editing the original iCal file.
 */
@RequiredArgsConstructor
@Slf4j
@Service
public class IcalExtenderService {

    /**
     * Query key for defining additional modules from other terms.
     */
    public static final String ADDITIONAL_MODULES_IDENTIFIER = "additional-modules";

    /**
     * Query key for defining modules that are to be excluded.
     */
    public static final String EXCLUDED_MODULES_IDENTIFIER = "excluded-modules";

    /**
     * Keyword so that Reclaim AI adds travel time before and after the events.
     */
    private static final String RECLAIM_DESCRIPTION_TRAVEL = "#needs_travel";

    /**
     * Repository interface for loading the original iCal file from the university website.
     */
    private final RaumzeitRepository raumzeitRepository;

    /**
     * Generate the extended iCal file and interpret the query parameters.
     *
     * @param academicCourse The academic course defining the main calendar.
     * @param mainTerm       The main term defining the main calendar.
     * @param requestParams  Optional parameters defining modules that are to be omitted and additional modules from other terms.
     * @return The ICalendar file containing the data of the edited main calendar.
     */
    public ICalendar getExtendedIcalFile(String academicCourse, String mainTerm, final MultiValueMap<String, String> requestParams) {
        log.debug("getExtendedIcalFile: academicCourse={}, mainTerm={}, requestParams={}", academicCourse, mainTerm, requestParams);
        ICalendar mainCalendar = getCalendar(academicCourse + "." + mainTerm);
        if (requestParams.containsKey(ADDITIONAL_MODULES_IDENTIFIER))
            addAdditionalModules(mainCalendar, requestParams.get(ADDITIONAL_MODULES_IDENTIFIER));
        if (requestParams.containsKey(EXCLUDED_MODULES_IDENTIFIER))
            excludeModules(mainCalendar, requestParams.get(EXCLUDED_MODULES_IDENTIFIER));
        alterDescription(mainCalendar);
        changeUid(mainCalendar); //because not  alle events in the original iCal file have unique ids.
        return mainCalendar;
    }

    /**
     * Define a random UUID for each event because by definition every iCal event needs to have a unique id and the iCal
     * generated by the university contains duplicate ids.
     *
     * @param mainCalendar The ICalendar object containing the data of the main calendar.
     */
    private void changeUid(ICalendar mainCalendar) {
        log.trace("changeUid mainCalendar={}", mainCalendar);
        mainCalendar.getEvents().forEach(event -> event.setUid(UUID.randomUUID().toString()));
    }

    /**
     * Add Reclaim AI specific keywords to the description.
     *
     * @param mainCalendar The ICalendar object containing the data of the main calendar.
     */
    private void alterDescription(ICalendar mainCalendar) {
        log.trace("alterDescription mainCalendar={}", mainCalendar);
        mainCalendar.getEvents()
                .forEach(event -> {
                    if (event.getDescription() != null) {
                        event.setDescription(
                                new StringBuilder(event.getDescription().getValue())
                                        .append(" ")
                                        .append(RECLAIM_DESCRIPTION_TRAVEL)
                                        .toString()
                        ); //TODO: use template processor STR when it is no preview feature anymore.
                    } else {
                        event.setDescription(RECLAIM_DESCRIPTION_TRAVEL);
                    }
                });
    }

    /**
     * Exclude all events of the given modules.
     *
     * @param mainCalendar     The ICalendar object containing the data of the main calendar.
     * @param moduleCollection The collection containing the modules that are to be cancelled (excluded).
     */
    private void excludeModules(ICalendar mainCalendar, Collection<String> moduleCollection) {
        log.trace("excludeModules mainCalendar={} moduleCollection={}", mainCalendar, moduleCollection);
        var modules = moduleCollection.stream()
                .map(modulesString -> modulesString.split(","))
                .flatMap(Arrays::stream)
                .map(module -> module.replaceAll("[\"”“]", "")).toList();
        mainCalendar.getEvents().stream()
                .filter(event -> event.getSummary() != null)
                .filter(event -> modules.contains(event.getSummary().getValue().trim()))
                .forEach(event -> event.setStatus(Status.cancelled()));
    }

    /**
     * Add additional modules to the main calendar.
     *
     * @param mainCalendar      The ICalendar object containing the data of the main calendar.
     * @param additionalModules The collection containing the list of modules from other terms that are to be added to
     *                          the main calendar.
     */
    private void addAdditionalModules(ICalendar mainCalendar, Collection<String> additionalModules) {
        log.trace("addAdditionalModules mainCalendar={} additionalModules={}", mainCalendar, additionalModules);
        parseTermModuleStrings(additionalModules).forEach((academicCourseAndTerm, modules) -> {
            final var termCalendar = getCalendar(academicCourseAndTerm);
            termCalendar.getEvents().stream()
                    .filter(event -> event.getSummary() != null)
                    .filter(event -> modules.contains(event.getSummary().getValue().trim()))
                    .forEach(mainCalendar::addEvent)
            ;
        });
    }

    /**
     * Method for parsing the term module strings.
     *
     * @param additionalModules Collection containing string of all term modules.
     * @return HashMap where each key is one term and course (e.g. wiib.4.b) and where each value contains the modules
     * of this term and course that are to be added to the main calendar.
     */
    private HashMap<String, Collection<String>> parseTermModuleStrings(Collection<String> additionalModules) {
        log.trace("parseTermModuleStrings additionalModules={}", additionalModules);
        final var termsAndModules = new HashMap<String, Collection<String>>();
        additionalModules.forEach(
                termAndModules -> Arrays.stream(termAndModules.split(","))
                        .forEach(modulesPerTermData -> {
                            final var splitData = Arrays.stream(modulesPerTermData.split("-")).toList();
                            final var termAndCourse = splitData.getFirst();
                            if (!termAndCourse.matches(ACADEMIC_COURSE_PATTERN + "\\." + TERM_PATTERN))
                                throw new InvalidTermException("Term not valid!");
                            final var modules = splitData.subList(1, splitData.size()).stream()
                                    .map(module -> module.replace("\"", ""))
                                    .toList();

                            if (termsAndModules.containsKey(termAndCourse))
                                termsAndModules.get(termAndCourse).addAll(modules);
                            else
                                termsAndModules.put(termAndCourse, modules);
                        })
        );
        return termsAndModules;
    }

    /**
     * Method for loading the calendar for a specific course and term from the university website.
     *
     * @param academicCourseAndTerm The course and term for which the calendar should be loaded.
     * @return The ICalendar object containing the data of the main calendar.
     */
    private ICalendar getCalendar(String academicCourseAndTerm) {
        log.trace("getCalendar: academicCourseAndTerm={}", academicCourseAndTerm);
        final var response = raumzeitRepository.getIcalForCourseAndTerm(academicCourseAndTerm.toUpperCase());
        final var raumzeitData = response.getBody();
        return Biweekly.parse(raumzeitData).first();
    }

}
